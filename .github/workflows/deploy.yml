name: Node.js CI

on:
  push:
    branches: ['master']

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [22.x]

    steps:
      # Step 1: Checkout code
      - name: üßæ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      #  Obtener y generar nueva versi√≥n
      - name: üè∑Ô∏è Obtener y generar nueva versi√≥n
        id: semver
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "√öltimo tag encontrado: $LAST_TAG"

          # Extrae versi√≥n sem√°ntica
          VERSION=$(echo "$LAST_TAG" | sed 's/v//')
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Buscar un nuevo tag que no exista
          while true; do
            PATCH=$((PATCH + 1))
            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"

            # Verifica si ya existe en remoto
            if ! git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
              break
            fi
          done

          echo "Nueva versi√≥n: $NEW_VERSION"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Etiquetamos y pusheamos
          git tag $NEW_VERSION
          git push origin $NEW_VERSION

          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

      # Obtener el commit short SHA(optinal- for versioning)
      - name: Set short git commit SHA
        id: commit
        uses: prompt/actions-commit-hash@v2

      - uses: actions/checkout@v4
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: npm
      # - run: npm ci
      # - run: npm run lint
      # - run: npm run format
      # - run: npm run build --if-present
      # Step 3: Install dependencies
      - name: üì¶ Install dependencies
        run: |
          echo "üì• Instalando dependencias..."
          npm install

        # Step 4: Build NestJS application
      - name: üîß Build application
        run: |
          echo "üî® Construyendo aplicaci√≥n NestJS..."
          npm run build

      # Step 5: Configure AWS credentials
      - name: üîê Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{secrets.AWS_REGION}}

      # Step 6: Log in to Amazon ECR
      - name: üîë Log in to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Step 7: Build, tag, and push Docker image to ECR
      - name: üöÄ Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }} # ‚Üê URL de tu repositorio ECR, por ejemplo: 222634373780.dkr.ecr.us-east-1.amazonaws.com
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }} # ‚Üê Nombre del repositorio en ECR, por ejemplo: api-gateway
          SHORT_COMMIT: ${{ steps.commit.outputs.short }}
          VERSION: ${{ steps.semver.outputs.version }}
          TAG_FINAL: ${{ steps.semver.outputs.version }}-${{ steps.commit.outputs.short }}
        run: |
          echo "üöß Construyendo imagen Docker con versi√≥n: $TAG_FINAL"
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$TAG_FINAL .

          echo "üì§ Subiendo imagen: $TAG_FINAL"
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$TAG_FINAL

          echo "‚úÖ Imagen construida y subida a ECR."

        # 8. Update kubeconfig for EKS
      - name: Update kubeconfig
        run: |
          echo "üöÄ Actualizando kubeconfig..."
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

        # 9. Update deployment in EKS(Kubernetes)
      - name: üö¢ Actualizar deployment en Kubernetes con nueva imagen
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          TAG_FINAL: ${{ steps.semver.outputs.version }}-${{ steps.commit.outputs.short }}
        run: |
          echo "üîÑ Actualizando deployment con nueva imagen: $TAG_FINAL"

          echo "ECR_REGISTRY: $ECR_REGISTRY"
          echo "ECR_REPOSITORY: $ECR_REPOSITORY"
          echo "TAG_FINAL: $TAG_FINAL"

          kubectl set image deployment/${{ secrets.K8S_DEPLOYMENT_NAME }} \
            ${{ secrets.K8S_CONTAINER_NAME }}=$ECR_REGISTRY/$ECR_REPOSITORY:$TAG_FINAL \
            --namespace=${{ secrets.K8S_NAMESPACE }}
          echo "‚úÖ Deployment actualizado en Kubernetes."

        # 10. Verificar si el deployment fue exitoso
      - name: ‚úÖ Verificar rollout del deployment
        run: |
          echo "üîç Verificando que el deployment se haya aplicado correctamente..."
          kubectl rollout status deployment/${{ secrets.K8S_DEPLOYMENT_NAME }} --namespace=${{ secrets.K8S_NAMESPACE }}
          echo "üéâ Rollout completado correctamente."
